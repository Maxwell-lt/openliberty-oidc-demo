# OpenLiberty OIDC Demo

This application shows a minimal example of how to get OIDC-based login working with an OpenLiberty server.

## Modifications from the template

### Enable features

* `jaxrs`: Enables use of JAX-RS to expose REST endpoints.
* `jsonb`: Enables REST endpoint methods to return a POJO, which can then be converted into JSON.
* `openidConnectClient-1.0`, `transportSecurity-1.0`, `appSecurity`: Enables the OpenLiberty server to act as an OIDC RP, and handle authentication flows.

### A brief aside on configuring the OIDC OP

Regardless of what authentication server you use, the basic configuration should be roughly the same. You will need to define a client in the auth server, and set these properties:

* Client ID and Client Secret: These can essentially be any strings, and will either be automatically generated by the auth server, or freely chosen. This application must have access to both the ID and secret, though the secret should never be exposed publicly.
* Disable public auth flows: An auth server can allow or disallow auth flows which allow the end user to obtain a copy of the access token or other resources. This can be something like the implicit grant flow, which places the access and ID tokens in a redirect URL, or an authorization code flow which doesn't require a client secret to make the /token call.
* Configure redirect URLs: Ensure that the redirect URL that OpenLiberty will pass to /authorize is allowed as a redirect URL. This will be something like https://localhost:9443/oidcclient/redirect/authelia.
* Set allowed scopes: OpenLiberty will request the openid and profile scopes.
* Allowed grant types: OpenLiberty will use the authorization code grant flow.
* Allowed response types: code
* Allowed response modes: form_post
* Allowed /token auth method: client_secret_post
* Disable requiring Pushed Authorization Requests (PAR): As far as I can tell, OpenLiberty does not support this security feature, so it must be disabled.

I used the Authelia authentication server for this experiment, which like all auth servers has some quirks. By default, Authelia will put only the bare minimum claims on the ID Token, which prevents us from obtaining the user's name. I had to create a custom claims policy in the config which allows the `name` claim to be included in ID Tokens, and attached that policy to the client registration.  

### Configuring OIDC options

I added an openidConnectClient element, and configured the following attributes:

* `id`: Unique ID for this client, will define the redirect callback URL.
* `clientId`: Client ID configured in the auth server, which is moderately safe to keep in plaintext.
* `clientSecret`: Client Secret configured in the auth server, which must be kept secure. I am pulling in the environment variable CLIENT_SECRET for this value.
* `discoveryEndpointUrl`: URL of the OIDC OP's discovery endpoint, which should end with /.well-known/openid-configuration. Defining this supersedes any other URLs that might be configured such as the authorization or token URLs, as the discovery endpoint lists all of those in a standard format.
* `authFilterRef`: ID of an authFilter for which this OIDC config will be used. The authFilter will be described below.
* `pkceCodeChallengeMethod`, `signatureAlgorithm`: These must match the algorithms used by the auth server.
* `userIdentifier`: This defaults to `sub`, and I set it instead to `name` to allow greeting the logged-in user. The claim defined here must exist on the ID Token, or the login will fail.
* `uniqueUserIdentifier`: This I set back to `sub` to prevent it from getting overridden, as `name` is not guaranteed by OIDC to be unique.
* `scope`: Request the scopes `openid` and `profile`.

As mentioned above, I also defined an auth filter to restrict which paths would use this authentication method, and set this filter to match any paths containing /api.

To get the @RolesAllowed annotation mentioned in the next section to work, I had to bind the special ALL_AUTHENTICATED_USERS subject to the "users" role in the webApplication configuration.

### Create a JAX-RS endpoint

The OpenLiberty template comes with the RestApplication class, which creates a JAX-RS root at /api. This is suitable for our purposes.

We can define a separate class (in this case HelloService) to expose an endpoint.

Adding the @Path annnotation at the class level defines the relative path of all endpoints in the class; here I set its value to /hello, putting all endpoints in the class at /api/hello.
I also added the @ApplicationScoped annotation, but I'm not currently sure of its purpose.

Adding the @Consumes and @Produces annotations allows specifying the media type of requests and responses, which I set to JSON.

I added two GET endpoints to HelloService. The first simply returns a HelloResponse POJO with the message field set to "Hello World".

The second GET endpoint uses a method-level @Path annotation to expose it at /api/hello/auth, as well as the @RolesAllowed annotation to trigger securing the endpoint. It also uses an `@Inject`ed `Principal` to get the name of the logged-in user, so that it can greet them by name.